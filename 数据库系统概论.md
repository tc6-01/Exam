# 数据库复习----救命篇

## 重点梳理

**第1章** **绪论**

本章主要内容：

数据库的基本概念，发展过程，数据库系统的特点及目的。数据模型的要素和类型。三种主要数据库模型。系统内部结构和组成。

**重点掌握：**

理解数据库的原理、概念和特点。能够描述数据管理技术的产生和发展、数据库系统的特点、数据库系统的组成；能够区分数据、数据库、数据库管理系统、数据库系统等相关概念；

**第2章** **关系数据库**

本章主要内容：

关系代数运算，关系模式，关系模型的存储结构。码，超码，候选码几外码的概念。

**重点掌握：**

主要在于如何使用，复杂的关系代数，如何用关系代数表述查询。关系代数与SQL语言查询的相互转换。

**第3章** **关系数据库标准语言****SQL**

本章主要内容：

SQL语言的基本概念，数据定义、查询和更新。单表查询，聚集函数。连接查询（自然连接、等值连接，外连接），嵌套查询（[NOT] EXIST谓词的使用），集合查询（[NOT] IN）。数据更新，数据删除，视图的使用

**重点掌握：**

查询更新和修改的基本SQL语句。重点在于如何用SQL语言描述复杂的查询问题，灵活使用SQL语句。可以根据课后习题和几次习题课的试题练习。

**第4章** **数据库安全性**

本章主要内容：

实现数据库系统安全性的技术和方法，用户身份鉴别的方法，存取控制技术：自主存取控制和强制存取控制，视图技术，审计技术，数据加密存储和加密传输

**重点掌握：**

了解概念，什么是自主存取控制方法和强制存取控制方法。授予回收和角色的SQL语句。

**第5章** **数据库完整性**

本章主要内容：

实体、参照和用户定义的完整性的概念。完整性约束命名子句和断言的SQL语句。

**重点掌握：**

主要在于理解概念，搞清楚这三类完整性约束的必要性和区别。

**第6章** **关系数据理论**

本章主要内容：

函数依赖与多值依赖的概念。1NF、2NF、3NF、BCNF、4NF是如何递进的。Amstrong公理系统的概念。

**重点掌握：**

关系范式在于理解。能够分辨关系模式属于哪一范式。Amstrong公理系统在于使用，可以计算最小依赖集和闭包。

**第7章** **数据库设计**

本章主要内容：

数据库设计六阶段，数据库设计的各级模式，概念结构和E-R模型。

**重点掌握：**

运用E-R图的绘制，关系模式的设计。

**第8章** **数据库编程**

本章主要内容：

了解基本概念。

**重点掌握：**

了解基本操作。

**第9章** **关系处理和查询优化**

本章主要内容：

查询的处理过程（分析、检查、优化、执行），查询优化（代数，物理），查询的执行。

**重点掌握：**

顺序排列，B+树，哈希索引在查询中的作用。相互之间的优劣势和适合场景。不同连接查询的块数。

**第10章**     **并发控制与恢复技术**

本章主要内容：

事务的基本概念以及特性，封锁、活锁死锁概念，重做与撤销操作。

**重点掌握：**

重点在于运用，两段锁的执行过程？如何判断可串形化和冲突可串行化？读锁和写锁的作用。使用日志恢复数据库。优先图绘制。 

关于概念：需要理解，能够判断给出的例子是否符合。

关于运用：能够根据例子进行运算。

## 第四章数据库安全性

### 定义

数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏

### 实现数据库安全性控制的常用方法和技术有：

( l ）用户标识和鉴别：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权。
( 2 ）存取控制：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。例如CZ 级中的自主存取控制( DAC ) , Bl 级中的强制存取控制（MAC ）。
( 3 ）视图机制：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。

( 4 ）审计：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。
( 5 ）数据加密：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。

## 第五章 数据库完整性

### 定义

数据库的完整性是指数据的正确性和相容性。

### 数据库的完整性概念与数据库的安全性概念有什么区别和联系？

数据的完整性和安全性是两个不同的概念，但是有一定的联系。前者是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出，即所谓垃圾进垃圾出（ Garba : e In Garba : e out ）所造成的无效操作和错误结果。后者是保护数据库防止恶意的破坏和非法的存取。也就是说，安全性措施的防范对象是非法用户和非法操作，完整性措施的防范对象是不合语义的数据。

## 第六章 关系数据理论

### 候选码

若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有多个候选码，则选定其中一个为主码。

### 范式

#### 1NF

属于第一范式关系的所有属性都不可再分，即数据项不可分。

#### 2NF

 若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，（不存在非主属性部分函数依赖与任何一个候选码）则关系R属于第二范式。

#### 3NF

 非主属性既不传递依赖于码，也不部分依赖于码。

#### BCNF

关系模式R<U,F>中，若每一个决定因素都包含码，则R<U,F>属于BCFN

#### 4NF

限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。

### 主属性

所有候选码的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性

### 关系模式规范化的基本步骤

​                				1NF

​             				 	↓   消除非主属性对码的部分函数依赖

消除决定因素    2NF

非码的非平凡       ↓   消除非主属性对码的传递函数依赖

函数依赖        	 3NF

​              					↓   消除主属性对码的部分和传递函数依赖

​               				BCNF 

​              					↓   消除非平凡且非函数依赖的多值依赖

​            				   4NF

### 函数依赖：在一个表里面，属性X可以映射到属性Y，也就是说知道了X就能确定Y，称X为决定因素。

#### 举栗子🌰：有一个关系模式S(Sno,Sname,Sage)

如果知道了一个学生的学号Sno，那我就能确定他的姓名Sname和年龄Sage。
![函数依赖](https://img-blog.csdnimg.cn/20201007124945586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plcmVteV9Uc2FuZw==,size_16,color_FFFFFF,t_70#pic_center)

当然，如果你强制规定学生姓名不能重复。那么，知道了一个学生的姓名也是可以确定其他属性的，这也是满足函数依赖关系的。

##### 注：平凡函数依赖和非平凡函数依赖在这里不做解释

### 2、完全函数依赖和部分函数依赖

#### 直接举栗子🌰：有一个关系模式S(Sno,Sname,Cno,Grade)

**完全函数依赖**：如果我想知道某位学生的某一门课的成绩Grade，那我必须得同时知道他的学号Sno和课程号Cno。

但如果我只知道一部分信息，比如他的Sno或者Cno可以吗？答案是不行的！**此时称Y[Grade]完全依赖于X[Sno,Cno]。**
![完全函数依赖](https://img-blog.csdnimg.cn/20201007125615949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plcmVteV9Uc2FuZw==,size_16,color_FFFFFF,t_70#pic_center)
**部分函数依赖**：如果我想知道某位学生的姓名Sname，那我知道他的学号Sno就可以了。也就是说**Y[Sname]只函数依赖于X[Sno,Cno]中的子集x[Sno**]**，此时称Y部分函数依赖于X。**
![部分函数依赖](https://img-blog.csdnimg.cn/20201007125449422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plcmVteV9Uc2FuZw==,size_16,color_FFFFFF,t_70#pic_center)

### 3、传递函数依赖

#### 直接讲人话🌰：有一个关系模式S(Sno,Sdept,Mname)

**如果我知道了一个学生的学号Sno，那我就能知道他所在的系Sdept。**(因为理论上一个学生只属于一个系)
**如果我知道了某一个系Sdept，那么我就能知道这个系的系主任的姓名Mname。**(一个系只有一个正的系主任，别杠，你赢了。)
也就是说，我知道了一个学生的学号Sno，其实我就知道了他所在系的系主任的姓名Mname。**但这个过程中，他们是不存在直接函数依赖的，我需要通过系名称Sdept作为一个桥梁去把二者联系起来的。**
![传递函数依赖](https://img-blog.csdnimg.cn/20201007125911413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plcmVteV9Uc2FuZw==,size_16,color_FFFFFF,t_70#pic_center)

### 最小函数依赖

举例

> 关系模式R(U，F)中，U={A，B，C，D，E，G}，F={B  → D，DG  → C,BD  → E,AG  → B,ADG  → BC}；求F的最小函数依赖集。

解：
1、首先根据函数依赖的分解性，对F进行第一次筛选，需要变动的有：
ADG  → BC拆解成ADG  → B、ADG  → C
得新函数依赖集：
F = {B  → D,DG  → C,BD  → E,AG  → B,ADG  → B,ADG  → C}

2、筛选多余的函数依赖

- 2.1：去除B  → D，得F = {DG  → C,BD  → E,AG  → B,ADG  → B,ADG  → C}，{B}F+ = {B}，不包含D，故B  → D不删除。
- 2.2：去除DG  → C，得F = {B  → D、BD  → E,AG  → B,ADG  → B,ADG  → C}，{DG}F+={D,G}，不包含C，故DG  → C不删除。
- 2.3：去除BD  → E，得F = {B  → D,DG  → C,AG  → B,ADG  → B,ADG  → C}，{BD}F+ = {B,D}，不包含E，故BD  → E不删除。
- 2.4：去除AG  → B，得F = {B  → D,DG  → C,BD  → E,ADG  → B,ADG  → C}，{AG}F+ = {A,G}，不包含B，故AG  → B不删除。
- 2.5：去除ADG  → B，得F = {B  → D,DG  → C,BD  → E,AG  → B,ADG  → C}， {ADG}F+ = {A,D,G,C,B,E}，包含B，**故ADG  → B去除**。
- 2.6：去除ADG  → C，得F = {B  → D,DG  → C,BD  → E,AG  → B,ADG  → B}， {ADG}F+ = {A,D,G,C,B,E}，包含C，**故ADG  → C去除**。
  经过第二部筛选后，函数依赖集F变为{B  → D,DG  → C,BD  → E,AG  → B}。

3、化简函数依赖左侧不为单个属性的函数依赖

- 3.1：先看DG  →C
  - 3.1.1：去除D，得G  → C，得函数依赖集F1 = {B  → D,G  → C,BD  → E,AG  → B}。
    基于F1，可求得 G F + G_F^+ GF+​ = {G,C}。
    基于F(第二步求出的，下同)，可求得 G F + G_F^+ GF+​ = {G}
    可见二者并不相同，所以D不去除。
  - 3.1.2：去除G，得D  → C，得函数依赖集F1 = {B  → D,D  → C,BD  → E,AG  → B}
    基于F1，可求得 D F + D_F^+ DF+​ = {D,C}
    基于F，可求得 D F + D_F^+ DF+​ ={D}
    可见二者并不相同，所以G不去除。

综上，DG  → C，已是最简。

- 3.2：再看BD  →E
  - 3.2.1：去除B，得D  → E，得函数依赖集F1 = {B  → D,DG  → C,D  → E,AG  → B}
    基于F1，可求得 D F + D_F^+ DF+​ = {D,E}
    基于F，可求得 D F + D_F^+ DF+​ = {D}
    可见二者并不相同，所以B不去除。
  - 3.2.2：去除D，得B  → E，得函数依赖集F1 = {B  → D,DG  → C,B  → E,AG  → B}
    基于F1，可求得 B F + B_F^+ BF+​ = {B,E,D}
    基于F，可求得 B F + B_F^+ BF+​ = {B,D,E}
    可见二者相同，所以D**可以去除**。

综上，BD  → E，可化简为B  → E。

- 3.3：最后看AG  →B
  - 3.3.1：去除A，得G  → B，得函数依赖集F1 = {B  → D,DG  → C,B  → E,G  → B}
    基于F1，可求得 G F + G_F^+ GF+​ = {G,B}
    基于F，可求得 G F + G_F^+ GF+​ = {G}
    可见二者并不相同，所以A不可去除。
  - 3.3.2：去除G，得A  → B，得函数依赖F1 = {B  → D,DG  → C,B  → E,A  → B}
    基于F1，可求得 A F + A_F^+ AF+​ = {A,B}
    基于F，可求得 A F + A_F^+ AF+​ = {A}
    可见二者并不相同，所以G不可去除。

综上，AG  → B，已是最简。
综上，R的最小函数依赖集为F = {B  → D,DG  → C,B  → E,AG  → B}

### 最小依赖函数求候选码

1. 仅在函数依赖集F中的依赖左边出现的属性必定属于候选码；

2. 仅在函数依赖集F中的依赖右边出现的属性必定是非主属性；

3. 函数依赖集F中的依赖两边均不出现的属性必定属于候选码；

4. 函数依赖集F中的依赖两边均出现的属性 与1.3选出的属性进行闭包运算，如果闭包结果为U，即候选码。

   